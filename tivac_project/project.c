//final code before freeartos


//main tiva c code
#define PART_TM4C123GH6PM

#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <string.h>
#include <stdio.h>

#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_gpio.h"
#include "inc/hw_i2c.h"
#include "inc/TM4C123GH6PM.h"
#include "TM4C123.h"

#include "driverlib/sysctl.h"
#include "driverlib/gpio.h"
#include "driverlib/i2c.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom.h"
#include "driverlib/adc.h"

#include <stdbool.h>
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/sysctl.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/uart.h"


//#define I2C_MODULE I2C3_BASE

#define ADC0_SEQUENCE 3 	//Heart Sensor ADC
//#define ADC1_SEQUENCE 3		//Temprature Sensor ADC


char buffer[100];
 //=== UART3 Initialization ===

void UART3_Init(void) {
    // Enable peripherals
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART3);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);
    
    // Wait for peripherals to be ready
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_UART3));
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOC));
    
    // Configure GPIO pins for UART
    GPIOPinConfigure(GPIO_PC6_U3RX);
    GPIOPinConfigure(GPIO_PC7_U3TX);
    GPIOPinTypeUART(GPIO_PORTC_BASE, GPIO_PIN_6 | GPIO_PIN_7);
    
    // Configure UART
    UARTConfigSetExpClk(UART3_BASE, SysCtlClockGet(), 9600,
                        (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
                         UART_CONFIG_PAR_NONE));
}

// === Send a single character through UART3 ===
void UART3_OutChar(char data) {
    while ((UART3_FR_R & (1 << 5)) != 0); // Wait until TXFF is 0 (Transmit FIFO Full flag clear)
    UART3_DR_R = data;
}

// === Send a full string through UART3 ===
void UART3_OutString(const char* str) {
    while (*str) {
        UART3_OutChar(*str++);
    }
}

// === PortF Initialization for SW1 and Green LED ===
void PortF_Init(void) {
    SYSCTL_RCGCGPIO_R |= (1 << 5);       // Enable clock for Port F
    while ((SYSCTL_PRGPIO_R & (1 << 5)) == 0) {};  // Wait for Port F ready

    GPIO_PORTF_LOCK_R = 0x4C4F4344;       // Unlock PF0
    GPIO_PORTF_CR_R |= 0x1F;              // Allow changes to PF4-0
    GPIO_PORTF_DIR_R |= (1 << 3);         // PF3 (Green LED) output
    GPIO_PORTF_DIR_R &= ~(1 << 4);        // PF4 (SW1) input
    GPIO_PORTF_DEN_R |= 0x18;             // Enable digital on PF3, PF4
    GPIO_PORTF_PUR_R |= (1 << 4);         // Pull-up resistor on PF4
}

// Initialize ADC0 on PE3 (AIN0)
void ADC0_Init(void) {
    SYSCTL_RCGCADC_R |= 1;
    SYSCTL_RCGCGPIO_R |= 0x10;  // enable PORTE
    GPIO_PORTE_AFSEL_R |= 0x08; // PE3
    GPIO_PORTE_DEN_R &= ~0x08;
    GPIO_PORTE_AMSEL_R |= 0x08;

    ADC0_ACTSS_R &= ~8;
    ADC0_EMUX_R &= ~0xF000;
    ADC0_SSMUX3_R = 0;
    ADC0_SSCTL3_R = 6;
    ADC0_ACTSS_R |= 8;
}

// Read analog value
uint32_t ADC0_Read(void) {
    ADC0_PSSI_R |= 8;
    while ((ADC0_RIS_R & 8) == 0);
    uint32_t result = ADC0_SSFIFO3_R;
    ADC0_ISC_R = 8;
    return result;
}



/*    ADC to read heart rate    */
void InitADC(void){
    SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);
    while (!SysCtlPeripheralReady(SYSCTL_PERIPH_ADC0)) {} 
    /* ui32Base                     :   ADCO.
      *ui32SequenceNum              :   SS3 (3).
      * ui32Trigger                 :   Generated by the Processor. 
      *ui32Priority                 :   Highest Priority (0).
    */
    ADCSequenceStepConfigure(ADC0_BASE, 3, ADC_TRIGGER_PROCESSOR, 0);
    /* ui32Base                     :   ADCO.
      *ui32SequenceNum              :   SS3 (3).
      * ui32Step                    :   The order in which the samples are captured (0). 
      *ui32Config                   :   Input Channel (CHO), The last in the sequence (END), cause interrupt on completing (IE)
    */
    ADCSequenceStepConfigure (ADC0_BASE, ADC0_SEQUENCE, 0, ADC_CTL_CH0 | ADC_CTL_END | ADC_CTL_IE);
    ADCSequenceEnable(ADC0_BASE, ADC0_SEQUENCE);
    ADCIntClear(ADC0_BASE, ADC0_SEQUENCE);  // Clear any prior interrupt
}



uint32_t ADCRead(void){
    uint32_t value = 0;
    ADCProcessorTrigger(ADC0_BASE, ADC0_SEQUENCE);
    while (!ADCIntStatus(ADC0_BASE, ADC0_SEQUENCE, false)) {}
    ADCIntClear(ADC0_BASE, ADC0_SEQUENCE);
    ADCSequenceDataGet(ADC0_BASE, ADC0_SEQUENCE, &value);
    return value;
}



int main(void) {
    UART3_Init();
    PortF_Init();
		InitADC();

    while (1) {
        if ((GPIO_PORTF_DATA_R & (1 << 4)) == 0) {   // SW1 pressed
						SysCtlDelay(SysCtlClockGet()/100);       // 10ms debounce
						if ((GPIO_PORTF_DATA_R & (1 << 4)) == 0) { // Still pressed
								uint32_t value = ADCRead();
								sprintf(buffer, "HR:%d\r\n", value);  // Fixed format
								UART3_OutString(buffer);
								GPIO_PORTF_DATA_R |= (1 << 3);        // LED on
								while ((GPIO_PORTF_DATA_R & (1 << 4)) == 0); // Wait release
								GPIO_PORTF_DATA_R &= ~(1 << 3);       // LED off
						}
				}else {
            GPIO_PORTF_DATA_R &= ~(1 << 3);          // Turn OFF Green LED
        }
    }
}